<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MKV オフラインプレイヤー (WebCodecs)</title>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: #f4f7f9;
            text-align: center;
        }
        #app {
            max-width: 800px;
            margin: 0 auto;
            background: #ffffff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            text-align: left;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-top: 0;
        }
        input[type="file"] {
            display: block;
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
        }
        #videoCanvas {
            width: 100%;
            max-height: 450px;
            background: #000;
            margin-top: 20px;
            border-radius: 4px;
        }
        #playback-status {
            margin-top: 15px;
            font-weight: bold;
            color: #007bff;
        }
        #resume-info {
            margin-top: 10px;
            font-size: 0.9em;
            color: #555;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>MKV オフラインプレイヤー</h1>
        <p>⚠️ Wi-Fiを切る前に、一度このページにアクセスし、ファイルをロードしてキャッシュを有効にしてください。</p>
        
        <input type="file" id="mkvFileInput">
        
        <div id="playback-status">ファイルを選択し、再生を開始します...</div>
        
        <canvas id="videoCanvas"></canvas>
        
        <div id="resume-info"></div>
    </div>
    
    <script type="module">
        // 外部の web-demuxer.js をローカルパスから ES Module としてインポート
        import { WebDemuxer } from './web-demuxer.js';

        // Service Workerの登録（オフライン化）
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('serviceworker.js').then(function(reg) {
                console.log('Service Worker Registered!', reg);
            }).catch(function(err) {
                console.log('Service Worker registration failed: ', err);
            });
        }
        
        // --- プレイヤーのメインロジック ---

        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('mkvFileInput');
            const canvas = document.getElementById('videoCanvas');
            const statusDiv = document.getElementById('playback-status');
            const resumeInfo = document.getElementById('resume-info');
            const ctx = canvas.getContext('2d');
            
            // 1. IndexedDBの初期化 (レジューム再生データの保存用)
            const dbName = 'mkvResumeDB';
            let db;

            const request = indexedDB.open(dbName, 1);
            
            request.onupgradeneeded = (event) => {
                db = event.target.result;
                db.createObjectStore('resumePositions', { keyPath: 'fileName' });
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log('IndexedDB ready.');
            };
            
            // 2. ファイル選択時の処理
            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                statusDiv.textContent = `${file.name} を読み込み中...`;
                
                // 4. レジューム位置の確認
                const resumeTime = await getResumePosition(file.name);
                if (resumeTime > 0) {
                    resumeInfo.textContent = `レジューム位置: ${resumeTime.toFixed(1)}秒から再生を試みます。`;
                } else {
                    resumeInfo.textContent = `新規再生を開始します。`;
                }
                
                // --- 🚨 5. WebCodecsとWebDemuxerの処理 ---
                
                try {
                    // 🚨 WASMファイルパスを明示的に指定してWebDemuxerを初期化
                    const demuxer = new WebDemuxer({
                        wasmFilePath: './web-demuxer.wasm' 
                    });
                    
                    await demuxer.load(file);
                    
                    const videoConfig = await demuxer.getDecoderConfig('video');
                    
                    // Canvasサイズの設定
                    canvas.width = videoConfig.codedWidth;
                    canvas.height = videoConfig.codedHeight;
                    
                    // 6. WebCodecs VideoDecoder のセットアップ
                    const decoder = new VideoDecoder({
                        output: (frame) => {
                            // デコードされたフレームをCanvasに描画
                            ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
                            frame.close(); // メモリ解放
                            
                            // 簡易的なレジューム位置の保存
                            const currentTime = frame.timestamp / 1000000;
                            saveResumePosition(file.name, currentTime);
                        },
                        error: (e) => {
                            statusDiv.textContent = `デコードエラー: ${e.message} (${videoConfig.codec})`;
                            console.error(e);
                        }
                    });

                    decoder.configure(videoConfig); 
                    
                    // 7. 映像チャンクのデキュー (再生処理の開始)
                    statusDiv.textContent = `${file.name} デコード処理を開始しました。`;
                    
                    // シーク（レジューム位置へ）
                    await demuxer.seek('video', resumeTime);
                    
                    // 8. 再生ループ (デコーダーにチャンクを渡す)
                    let packet = null;
                    while (decoder.state !== 'closed') {
                        // 1パケットずつ読み込む (高速化したい場合は一度に多く読み込めます)
                        packet = await demuxer.read('video', 1);
                        
                        if (!packet) {
                            // ファイルの終わりに到達
                            break; 
                        }
                        
                        const chunk = new EncodedVideoChunk({
                            type: packet.isKeyframe ? 'key' : 'delta',
                            // web-demuxerはPTSを秒で返すため、WebCodecsの単位（マイクロ秒）に変換
                            timestamp: packet.pts * 1000000, 
                            data: packet.data
                        });
                        
                        decoder.decode(chunk);
                        
                        // 簡易的な再生速度制御 (過負荷防止)
                        // 厳密な同期処理はより複雑になりますが、これでひとまず動きます
                        await new Promise(r => setTimeout(r, 1000 / 60)); 
                    }
                    
                    // 最後のデコード完了を待つ
                    await decoder.flush(); 

                    statusDiv.textContent = `${file.name} 再生完了。`;
                    await saveResumePosition(file.name, 0); // 完了したらリセット

                } catch (error) {
                    statusDiv.textContent = `再生失敗: デムクサーのロードまたは初期化に失敗しました。詳細をコンソールで確認してください。`;
                    console.error('再生ロジックエラー:', error);
                    return;
                }
            });

            // 9. IndexedDBのレジューム保存/取得関数
            function saveResumePosition(fileName, time) {
                return new Promise((resolve) => {
                    if (!db) return resolve();
                    const transaction = db.transaction(['resumePositions'], 'readwrite');
                    const store = transaction.objectStore('resumePositions');
                    store.put({ fileName: fileName, time: time });
                    transaction.oncomplete = resolve;
                });
            }

            function getResumePosition(fileName) {
                return new Promise((resolve) => {
                    if (!db) return resolve(0);
                    const transaction = db.transaction(['resumePositions'], 'readonly');
                    const store = transaction.objectStore('resumePositions');
                    const request = store.get(fileName);
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result ? event.target.result.time : 0);
                    };
                    request.onerror = () => resolve(0);
                });
            }
        });
    </script>
</body>
</html>
