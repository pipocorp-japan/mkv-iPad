<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MKV ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (WebCodecs)</title>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: #f4f7f9;
            text-align: center;
        }
        #app {
            max-width: 800px;
            margin: 0 auto;
            background: #ffffff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            text-align: left;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-top: 0;
        }
        input[type="file"] {
            display: block;
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
        }
        #videoCanvas {
            width: 100%;
            max-height: 450px;
            background: #000;
            margin-top: 20px;
            border-radius: 4px;
        }
        #playback-status {
            margin-top: 15px;
            font-weight: bold;
            color: #007bff;
        }
        #resume-info {
            margin-top: 10px;
            font-size: 0.9em;
            color: #555;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>MKV ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</h1>
        <p>âš ï¸ Wi-Fiã‚’åˆ‡ã‚‹å‰ã«ã€ä¸€åº¦ã“ã®ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„ã€‚</p>
        
        <input type="file" id="mkvFileInput">
        
        <div id="playback-status">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã€å†ç”Ÿã‚’é–‹å§‹ã—ã¾ã™...</div>
        
        <canvas id="videoCanvas"></canvas>
        
        <div id="resume-info"></div>
    </div>
    
    <script type="module">
        // å¤–éƒ¨ã® web-demuxer.js ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ ES Module ã¨ã—ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { WebDemuxer } from './web-demuxer.js';

        // Service Workerã®ç™»éŒ²ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³åŒ–ï¼‰
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('serviceworker.js').then(function(reg) {
                console.log('Service Worker Registered!', reg);
            }).catch(function(err) {
                console.log('Service Worker registration failed: ', err);
            });
        }
        
        // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---

        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('mkvFileInput');
            const canvas = document.getElementById('videoCanvas');
            const statusDiv = document.getElementById('playback-status');
            const resumeInfo = document.getElementById('resume-info');
            const ctx = canvas.getContext('2d');
            
            // 1. IndexedDBã®åˆæœŸåŒ– (ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ å†ç”Ÿãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ç”¨)
            const dbName = 'mkvResumeDB';
            let db;

            const request = indexedDB.open(dbName, 1);
            
            request.onupgradeneeded = (event) => {
                db = event.target.result;
                db.createObjectStore('resumePositions', { keyPath: 'fileName' });
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log('IndexedDB ready.');
            };
            
            // 2. ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠæ™‚ã®å‡¦ç†
            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                statusDiv.textContent = `${file.name} ã‚’èª­ã¿è¾¼ã¿ä¸­...`;
                
                // 4. ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ä½ç½®ã®ç¢ºèª
                const resumeTime = await getResumePosition(file.name);
                if (resumeTime > 0) {
                    resumeInfo.textContent = `ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ä½ç½®: ${resumeTime.toFixed(1)}ç§’ã‹ã‚‰å†ç”Ÿã‚’è©¦ã¿ã¾ã™ã€‚`;
                } else {
                    resumeInfo.textContent = `æ–°è¦å†ç”Ÿã‚’é–‹å§‹ã—ã¾ã™ã€‚`;
                }
                
                // --- ğŸš¨ 5. WebCodecsã¨WebDemuxerã®å‡¦ç† ---
                
                try {
                    // ğŸš¨ WASMãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã—ã¦WebDemuxerã‚’åˆæœŸåŒ–
                    const demuxer = new WebDemuxer({
                        wasmFilePath: './web-demuxer.wasm' 
                    });
                    
                    await demuxer.load(file);
                    
                    const videoConfig = await demuxer.getDecoderConfig('video');
                    
                    // Canvasã‚µã‚¤ã‚ºã®è¨­å®š
                    canvas.width = videoConfig.codedWidth;
                    canvas.height = videoConfig.codedHeight;
                    
                    // 6. WebCodecs VideoDecoder ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
                    const decoder = new VideoDecoder({
                        output: (frame) => {
                            // ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’Canvasã«æç”»
                            ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
                            frame.close(); // ãƒ¡ãƒ¢ãƒªè§£æ”¾
                            
                            // ç°¡æ˜“çš„ãªãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ä½ç½®ã®ä¿å­˜
                            const currentTime = frame.timestamp / 1000000;
                            saveResumePosition(file.name, currentTime);
                        },
                        error: (e) => {
                            statusDiv.textContent = `ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${e.message} (${videoConfig.codec})`;
                            console.error(e);
                        }
                    });

                    decoder.configure(videoConfig); 
                    
                    // 7. æ˜ åƒãƒãƒ£ãƒ³ã‚¯ã®ãƒ‡ã‚­ãƒ¥ãƒ¼ (å†ç”Ÿå‡¦ç†ã®é–‹å§‹)
                    statusDiv.textContent = `${file.name} ãƒ‡ã‚³ãƒ¼ãƒ‰å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚`;
                    
                    // ã‚·ãƒ¼ã‚¯ï¼ˆãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ä½ç½®ã¸ï¼‰
                    await demuxer.seek('video', resumeTime);
                    
                    // 8. å†ç”Ÿãƒ«ãƒ¼ãƒ— (ãƒ‡ã‚³ãƒ¼ãƒ€ãƒ¼ã«ãƒãƒ£ãƒ³ã‚¯ã‚’æ¸¡ã™)
                    let packet = null;
                    while (decoder.state !== 'closed') {
                        // 1ãƒ‘ã‚±ãƒƒãƒˆãšã¤èª­ã¿è¾¼ã‚€ (é«˜é€ŸåŒ–ã—ãŸã„å ´åˆã¯ä¸€åº¦ã«å¤šãèª­ã¿è¾¼ã‚ã¾ã™)
                        packet = await demuxer.read('video', 1);
                        
                        if (!packet) {
                            // ãƒ•ã‚¡ã‚¤ãƒ«ã®çµ‚ã‚ã‚Šã«åˆ°é”
                            break; 
                        }
                        
                        const chunk = new EncodedVideoChunk({
                            type: packet.isKeyframe ? 'key' : 'delta',
                            // web-demuxerã¯PTSã‚’ç§’ã§è¿”ã™ãŸã‚ã€WebCodecsã®å˜ä½ï¼ˆãƒã‚¤ã‚¯ãƒ­ç§’ï¼‰ã«å¤‰æ›
                            timestamp: packet.pts * 1000000, 
                            data: packet.data
                        });
                        
                        decoder.decode(chunk);
                        
                        // ç°¡æ˜“çš„ãªå†ç”Ÿé€Ÿåº¦åˆ¶å¾¡ (éè² è·é˜²æ­¢)
                        // å³å¯†ãªåŒæœŸå‡¦ç†ã¯ã‚ˆã‚Šè¤‡é›‘ã«ãªã‚Šã¾ã™ãŒã€ã“ã‚Œã§ã²ã¨ã¾ãšå‹•ãã¾ã™
                        await new Promise(r => setTimeout(r, 1000 / 60)); 
                    }
                    
                    // æœ€å¾Œã®ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†ã‚’å¾…ã¤
                    await decoder.flush(); 

                    statusDiv.textContent = `${file.name} å†ç”Ÿå®Œäº†ã€‚`;
                    await saveResumePosition(file.name, 0); // å®Œäº†ã—ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ

                } catch (error) {
                    statusDiv.textContent = `å†ç”Ÿå¤±æ•—: ãƒ‡ãƒ ã‚¯ã‚µãƒ¼ã®ãƒ­ãƒ¼ãƒ‰ã¾ãŸã¯åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
                    console.error('å†ç”Ÿãƒ­ã‚¸ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', error);
                    return;
                }
            });

            // 9. IndexedDBã®ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ä¿å­˜/å–å¾—é–¢æ•°
            function saveResumePosition(fileName, time) {
                return new Promise((resolve) => {
                    if (!db) return resolve();
                    const transaction = db.transaction(['resumePositions'], 'readwrite');
                    const store = transaction.objectStore('resumePositions');
                    store.put({ fileName: fileName, time: time });
                    transaction.oncomplete = resolve;
                });
            }

            function getResumePosition(fileName) {
                return new Promise((resolve) => {
                    if (!db) return resolve(0);
                    const transaction = db.transaction(['resumePositions'], 'readonly');
                    const store = transaction.objectStore('resumePositions');
                    const request = store.get(fileName);
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result ? event.target.result.time : 0);
                    };
                    request.onerror = () => resolve(0);
                });
            }
        });
    </script>
</body>
</html>
